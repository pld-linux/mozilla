Index: nsAppShell.cpp
===================================================================
RCS file: /cvsroot/mozilla/widget/src/gtk2/nsAppShell.cpp,v
retrieving revision 1.5
diff -u -r1.5 nsAppShell.cpp
--- mozilla/widget/src/gtk2/nsAppShell.cpp	12 Jan 2002 07:14:53 -0000	1.5
+++ mozilla/widget/src/gtk2/nsAppShell.cpp	11 Apr 2002 15:16:02 -0000
@@ -48,6 +48,10 @@
 static PLHashTable *sQueueHashTable = nsnull;
 static PLHashTable *sCountHashTable = nsnull;
 
+#ifdef PR_LOGGING
+PRLogModuleInfo *gWidgetLog = nsnull;
+#endif
+
 static gboolean event_processor_callback (GIOChannel *source,
 					  GIOCondition condition,
 					  gpointer data)
@@ -71,6 +75,11 @@
 nsAppShell::nsAppShell(void)
 {
   NS_INIT_REFCNT();
+
+#ifdef PR_LOGGING
+  if (!gWidgetLog)
+    gWidgetLog = PR_NewLogModule("Widget");
+#endif
 }
 
 nsAppShell::~nsAppShell(void)
Index: nsCommonWidget.cpp
===================================================================
RCS file: /cvsroot/mozilla/widget/src/gtk2/nsCommonWidget.cpp,v
retrieving revision 1.9
diff -u -r1.9 nsCommonWidget.cpp
--- mozilla/widget/src/gtk2/nsCommonWidget.cpp	15 Mar 2002 05:08:44 -0000	1.9
+++ mozilla/widget/src/gtk2/nsCommonWidget.cpp	11 Apr 2002 15:16:02 -0000
@@ -36,10 +36,6 @@
 #include "nsCommonWidget.h"
 #include "nsGtkKeyUtils.h"
 
-#ifdef PR_LOGGING
-PRLogModuleInfo *gWidgetLog = nsnull;
-#endif
-
 nsCommonWidget::nsCommonWidget()
 {
   mIsTopLevel       = PR_FALSE;
@@ -52,12 +48,6 @@
 
   mPreferredWidth   = 0;
   mPreferredHeight  = 0;
-
-#ifdef PR_LOGGING
-  if (!gWidgetLog)
-    gWidgetLog = PR_NewLogModule("Widget");
-#endif
-
 }
 
 nsCommonWidget::~nsCommonWidget()
Index: nsWindow.cpp
===================================================================
RCS file: /cvsroot/mozilla/widget/src/gtk2/nsWindow.cpp,v
retrieving revision 1.25
diff -u -r1.25 nsWindow.cpp
--- mozilla/widget/src/gtk2/nsWindow.cpp	23 Mar 2002 22:26:26 -0000	1.25
+++ mozilla/widget/src/gtk2/nsWindow.cpp	11 Apr 2002 15:16:03 -0000
@@ -209,11 +209,13 @@
   if (mShell) {
     gtk_widget_destroy(mShell);
     mShell = nsnull;
+    mContainer = nsnull;
   }
-
-  mContainer = nsnull;
-
-  if (mDrawingarea) {
+  else if (mContainer) {
+    gtk_widget_destroy(GTK_WIDGET(mContainer));
+    mContainer = nsnull;
+  }
+  else if (mDrawingarea) {
     g_object_unref(mDrawingarea);
     mDrawingarea = nsnull;
   }
@@ -1183,21 +1185,24 @@
 
   // figure out our parent window
   MozDrawingarea *parentArea = nsnull;
-  MozContainer   *parentContainer = nsnull;
+  MozContainer   *parentMozContainer = nsnull;
+  GtkContainer   *parentGtkContainer = nsnull;
+  GdkWindow      *parentGdkWindow = nsnull;
   GtkWindow      *topLevelParent = nsnull;
-  if (aParent || aNativeParent) {
-    GdkWindow *parentWindow;
-    // get the drawing area and the container from the parent
-    if (aParent)
-      parentWindow = GDK_WINDOW(aParent->GetNativeData(NS_NATIVE_WINDOW));
-    else
-      parentWindow = GDK_WINDOW(aNativeParent);
 
+  if (aParent)
+    parentGdkWindow = GDK_WINDOW(aParent->GetNativeData(NS_NATIVE_WINDOW));
+  else if (aNativeParent && GDK_IS_WINDOW(aNativeParent))
+    parentGdkWindow = GDK_WINDOW(aNativeParent);
+  else if (aNativeParent && GTK_IS_CONTAINER(aNativeParent))
+    parentGtkContainer = GTK_CONTAINER(aNativeParent);
+
+  if (parentGdkWindow) {
     // find the mozarea on that window
     gpointer user_data = nsnull;
-    user_data = g_object_get_data(G_OBJECT(parentWindow), "mozdrawingarea");
+    user_data = g_object_get_data(G_OBJECT(parentGdkWindow), "mozdrawingarea");
     parentArea = MOZ_DRAWINGAREA(user_data);
-
+    
     NS_ASSERTION(parentArea, "no drawingarea for parent widget!\n");
     if (!parentArea)
       return NS_ERROR_FAILURE;
@@ -1210,15 +1215,15 @@
       return NS_ERROR_FAILURE;
 
     // XXX support generic containers here for embedding!
-    parentContainer = MOZ_CONTAINER(user_data);
-    NS_ASSERTION(parentContainer, "owning widget is not a mozcontainer!\n");
-    if (!parentContainer)
+    parentMozContainer = MOZ_CONTAINER(user_data);
+    NS_ASSERTION(parentMozContainer, "owning widget is not a mozcontainer!\n");
+    if (!parentMozContainer)
       return NS_ERROR_FAILURE;
 
     // get the toplevel window just in case someone needs to use it
     // for setting transients or whatever.
     topLevelParent =
-      GTK_WINDOW(gtk_widget_get_toplevel(GTK_WIDGET(parentContainer)));
+      GTK_WINDOW(gtk_widget_get_toplevel(GTK_WIDGET(parentMozContainer)));
   }
 
   // ok, create our windows
@@ -1278,7 +1283,16 @@
     break;
   case eWindowType_child:
     {
-      mDrawingarea = moz_drawingarea_new(parentArea, parentContainer);
+      if (parentMozContainer) {
+	mDrawingarea = moz_drawingarea_new(parentArea, parentMozContainer);
+      }
+      else {
+	mContainer = MOZ_CONTAINER(moz_container_new());
+	gtk_container_add(parentGtkContainer, GTK_WIDGET(mContainer));
+	gtk_widget_realize(GTK_WIDGET(mContainer));
+
+	mDrawingarea = moz_drawingarea_new(nsnull, mContainer);
+      }
     }
     break;
   default:
@@ -1310,6 +1324,7 @@
     g_signal_connect(G_OBJECT(mShell), "delete_event",
 		     G_CALLBACK(delete_event_cb), NULL);
   }
+
   if (mContainer) {
     g_signal_connect_after(G_OBJECT(mContainer), "size_allocate",
 			   G_CALLBACK(size_allocate_cb), NULL);
@@ -1344,11 +1359,13 @@
     LOG(("\tmShell %p %p %lx\n", (void *)mShell, (void *)mShell->window,
 	 GDK_WINDOW_XWINDOW(mShell->window)));
   }
+
   if (mContainer) {
     LOG(("\tmContainer %p %p %lx\n", (void *)mContainer,
 	 (void *)GTK_WIDGET(mContainer)->window,
 	 GDK_WINDOW_XWINDOW(GTK_WIDGET(mContainer)->window)));
   }
+
   if (mDrawingarea) {
     LOG(("\tmDrawingarea %p %p %p %lx %lx\n", (void *)mDrawingarea,
 	 (void *)mDrawingarea->clip_window,
@@ -1372,8 +1389,17 @@
   // clear our resize flag
   mNeedsResize = PR_FALSE;
 
-  if (mIsTopLevel)
+  if (mIsTopLevel) {
     gtk_window_resize(GTK_WINDOW(mShell), aWidth, aHeight);
+  }
+  else if (mContainer) {
+    GtkAllocation allocation;
+    allocation.x = 0;
+    allocation.y = 0;
+    allocation.width = aWidth;
+    allocation.height = aHeight;
+    gtk_widget_size_allocate(GTK_WIDGET(mContainer), &allocation);
+  }
   
   moz_drawingarea_resize (mDrawingarea, aWidth, aHeight);
 }
@@ -1404,6 +1430,15 @@
       moz_drawingarea_resize(mDrawingarea, aWidth, aHeight);
     }
   }
+  else if (mContainer) {
+    GtkAllocation allocation;
+    allocation.x = 0;
+    allocation.y = 0;
+    allocation.width = aWidth;
+    allocation.height = aHeight;
+    gtk_widget_size_allocate(GTK_WIDGET(mContainer), &allocation);
+    moz_drawingarea_move_resize(mDrawingarea, aX, aY, aWidth, aHeight);
+  }
   else {
     moz_drawingarea_move_resize(mDrawingarea, aX, aY, aWidth, aHeight);
   }
@@ -1422,8 +1457,12 @@
       gtk_widget_show(mShell);
       
     }
+    else if (mContainer) {
+      moz_drawingarea_set_visibility(mDrawingarea, TRUE);
+      gtk_widget_show(GTK_WIDGET(mContainer));
+    }
     else {
-      moz_drawingarea_set_visibility(mDrawingarea, aAction);
+      moz_drawingarea_set_visibility(mDrawingarea, TRUE);
     }
   }
   else {
@@ -1431,7 +1470,11 @@
       gtk_widget_hide(GTK_WIDGET(mShell));
       gtk_widget_hide(GTK_WIDGET(mContainer));
     }
-    moz_drawingarea_set_visibility(mDrawingarea, aAction);
+    else if (mContainer) {
+      gtk_widget_hide(GTK_WIDGET(mContainer));
+      moz_drawingarea_set_visibility(mDrawingarea, FALSE);
+    }
+    moz_drawingarea_set_visibility(mDrawingarea, FALSE);
   }
 }
 
